# network.py

import argparse
import time
import requests
import json
import os
import shutil
from flask import Flask, request, jsonify
from blockchain import Blockchain, Block
from transaction import Transaction
from collections import deque
import threading

app = Flask(__name__)

# â€” ì²´ì¸ íŒŒì¼ ê²½ë¡œ & P2P ë¸”ë¡ì²´ì¸ & ë©”ëª¨ë¦¬í’€ â€”
CHAIN_FILE  = 'chain_data.json'
BACKUP_FILE = 'backup_chain.json'
blockchain  = Blockchain(difficulty=2)
nodes       = set()       # register_node ë¡œ ê´€ë¦¬ë˜ëŠ” í”¼ì–´ ì£¼ì†Œ ëª¨ìŒ
mempool     = deque()     # ë¸”ë¡ì— í¬í•¨ë˜ì§€ ì•Šì€ íŠ¸ëœì­ì…˜ ëŒ€ê¸°ì—´

def load_chain_from_disk():
    """ì¬ì‹œì‘ ì‹œ ì´ì „ì— ì €ì¥ëœ ì²´ì¸ì„ ë¶ˆëŸ¬ì˜µë‹ˆë‹¤."""
    if os.path.exists(CHAIN_FILE):
        with open(CHAIN_FILE, 'r', encoding='utf-8') as f:
            data = json.load(f)
        blockchain.chain.clear()
        for blk in data:
            b = Block(
                blk['index'],
                blk['timestamp'],
                blk['data'],
                blk['previous_hash']
            )
            b.nonce, b.hash = blk['nonce'], blk['hash']
            blockchain.chain.append(b)
        print(f"âœ… Loaded chain from {CHAIN_FILE}, length={len(blockchain.chain)}")
    else:
        print("âš ï¸ No existing chain file found; using fresh genesis block")

def save_chain_to_disk():
    """ì²´ì¸ì— ë¸”ë¡ì´ ì¶”ê°€ë  ë•Œë§ˆë‹¤ ì „ì²´ ì²´ì¸ì„ ë””ìŠ¤í¬ì— ë¤í”„í•˜ê³  ì¦‰ì‹œ ë°±ì—…í•©ë‹ˆë‹¤."""
    # 1) chain_data.jsonì— ì €ì¥
    with open(CHAIN_FILE, 'w', encoding='utf-8') as f:
        json.dump([b.__dict__ for b in blockchain.chain],
                  f, ensure_ascii=False, indent=2)
    # 2) backup_chain.jsonìœ¼ë¡œ ë³µì‚¬
    shutil.copy2(CHAIN_FILE, BACKUP_FILE)
    print(f"ğŸ’¾ Saved chain to {CHAIN_FILE} and backup to {BACKUP_FILE}, length={len(blockchain.chain)}")

@app.route('/register_node', methods=['POST'])
def register_node():
    data = request.get_json()
    peers = data.get('nodes')
    if not peers:
        return jsonify({'error': 'ë“±ë¡í•  ë…¸ë“œ ì£¼ì†Œë¥¼ ì œê³µí•˜ì„¸ìš”.'}), 400
    for peer in peers:
        nodes.add(peer)
    return jsonify({'message': 'ë…¸ë“œ ë“±ë¡ ì™„ë£Œ', 'all_nodes': list(nodes)}), 201

@app.route('/chain', methods=['GET'])
def get_chain():
    chain_data = [{
        'index': b.index,
        'timestamp': b.timestamp,
        'data': b.data,
        'previous_hash': b.previous_hash,
        'nonce': b.nonce,
        'hash': b.hash
    } for b in blockchain.chain]
    return jsonify({'length': len(chain_data), 'chain': chain_data}), 200

@app.route('/add_block', methods=['POST'])
def add_block():
    """
    ë‹¤ë¥¸ ë…¸ë“œì—ì„œ ì „íŒŒëœ ë¸”ë¡ ìˆ˜ì‹ 
    ìš”ì²­ í˜•ì‹: { 'block': {...}, 'proof': 'hash' }
    """
    # í•­ìƒ ìµœì‹  ë””ìŠ¤í¬ ì²´ì¸ ë¡œë“œ
    load_chain_from_disk()

    data  = request.get_json() or {}
    blk   = data.get('block')
    proof = data.get('proof')
    if not blk or proof is None:
        return jsonify({'error': 'block ë° proofë¥¼ ë³´ë‚´ì£¼ì„¸ìš”.'}), 400

    # Block ê°ì²´ë¡œ ë³µì›
    b = Block(
        blk['index'],
        blk['timestamp'],
        blk['data'],
        blk['previous_hash']
    )
    b.nonce, b.hash = blk['nonce'], blk['hash']

    added = blockchain.add_block(b, proof)
    if not added:
        return jsonify({'message': 'ë¸”ë¡ ìˆ˜ì‹  ê±°ë¶€'}), 400

    # ë””ìŠ¤í¬ì— ì €ì¥ & ë°±ì—…
    save_chain_to_disk()
    return jsonify({'message': 'ë¸”ë¡ ì¶”ê°€ ì™„ë£Œ'}), 201

@app.route('/new_transaction', methods=['POST'])
def new_transaction():
    """
    ì„¼ì„œë‚˜ ì™¸ë¶€ì—ì„œ ì „ì†¡ëœ íŠ¸ëœì­ì…˜ì„ mempoolì— ì €ì¥í•˜ê³ ,
    ë“±ë¡ëœ ëª¨ë“  í”¼ì–´ì—ê²Œ ì¬ì „íŒŒí•©ë‹ˆë‹¤.
    """
    data = request.get_json()
    tx   = Transaction(data['uid'], data['door'], timestamp=data['timestamp'])
    mempool.append(tx)

    for peer in nodes:
        try:
            requests.post(
                f'http://{peer}/new_transaction',
                json=tx.to_dict(),
                timeout=3
            )
        except requests.RequestException:
            pass

    return jsonify({
        'message': 'Transaction added to mempool',
        'mempool_size': len(mempool)
    }), 201

@app.route('/nodes/resolve', methods=['GET'])
def consensus():
    """
    ì»¨ì„¼ì„œìŠ¤ ì•Œê³ ë¦¬ì¦˜: ê°€ì¥ ê¸´ ì²´ì¸ì„ ì°¾ì•„ êµì²´í•©ë‹ˆë‹¤.
    """
    replaced = False
    max_len  = len(blockchain.chain)
    new_chain = None

    for peer in nodes:
        try:
            res = requests.get(f'http://{peer}/chain', timeout=3).json()
            length, chain_data = res['length'], res['chain']
            if length > max_len and blockchain.is_chain_valid():
                max_len, new_chain, replaced = length, chain_data, True
        except requests.RequestException:
            continue

    if replaced and new_chain:
        reconstructed = []
        for blk in new_chain:
            b = Block(
                blk['index'],
                blk['timestamp'],
                blk['data'],
                blk['previous_hash']
            )
            b.nonce, b.hash = blk['nonce'], blk['hash']
            reconstructed.append(b)
        blockchain.chain = reconstructed
        save_chain_to_disk()

    return jsonify({
        'replaced': replaced,
        'chain': [b.__dict__ for b in blockchain.chain]
    }), 200

def mine_loop():
    """
    10ì´ˆë§ˆë‹¤ mempool ì„ ë¹„ì›Œ ë¸”ë¡ìœ¼ë¡œ ì±„êµ´í•©ë‹ˆë‹¤.
    """
    while True:
        if mempool:
            print(f"â³ Mining start: mempool size = {len(mempool)}")
            txs = [tx.to_dict() for tx in list(mempool)]
            mempool.clear()

            last = blockchain.last_block()
            new_block = Block(
                index=last.index + 1,
                timestamp=time.time(),
                data=txs,
                previous_hash=last.hash
            )
            proof = blockchain.proof_of_work(new_block)
            blockchain.add_block(new_block, proof)
            print(f"â›ï¸  Mined block #{new_block.index} â†’ {new_block.hash}")

            for peer in nodes:
                try:
                    requests.post(
                        f'http://{peer}/add_block',
                        json={'block': new_block.__dict__, 'proof': proof},
                        timeout=3
                    )
                except requests.RequestException:
                    pass

            save_chain_to_disk()
            print(f"âœ… Mining done: mempool size = {len(mempool)}")

        time.sleep(10)

if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='P2P ë„¤íŠ¸ì›Œí¬ ë…¸ë“œ')
    parser.add_argument('--port', type=int, default=5000, help='ë¦¬ìŠ¤ë‹ í¬íŠ¸')
    args = parser.parse_args()

    load_chain_from_disk()
    threading.Thread(target=mine_loop, daemon=True).start()

    print(f"ğŸŒ Node listening on port {args.port} â€¦")
    app.run(host='0.0.0.0', port=args.port)
