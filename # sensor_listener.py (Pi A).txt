# sensor_listener.py (Pi A)
import os
import json
import shutil
import time
import requests
import RPi.GPIO as GPIO
from mfrc522 import SimpleMFRC522
from blockchain import Block, Blockchain

# RPLCDë¥¼ ì´ìš©í•œ I2C LCD ë¼ì´ë¸ŒëŸ¬ë¦¬
from RPLCD.i2c import CharLCD

# â€” ì•± ê¸°ë³¸ ê²½ë¡œ & static í´ë” ì„¤ì • â€”
BASE_DIR   = os.path.dirname(os.path.abspath(__file__))
STATIC_DIR = os.path.join(BASE_DIR, 'static')
if not os.path.exists(STATIC_DIR):
    os.makedirs(STATIC_DIR)

# â€” ì²´ì¸ íŒŒì¼ ê²½ë¡œ (static ì•„ë˜) â€”
CHAIN_FILE  = os.path.join(STATIC_DIR, 'chain_data.json')
BACKUP_FILE = os.path.join(STATIC_DIR, 'backup_chain.json')

# í•˜ë“œì›¨ì–´ ì„¤ì •
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)
READER     = SimpleMFRC522()
PIN_DOOR   = 18      # BCM 18 (Physical 12)
SERVO_PIN  = 17      # BCM 17
# Pi B Flask API endpoint for user list
USER_API   = "http://172.20.10.9:8000/api/users"

GPIO.setup(PIN_DOOR, GPIO.IN, pull_up_down=GPIO.PUD_DOWN)
GPIO.setup(SERVO_PIN, GPIO.OUT)
servo = GPIO.PWM(SERVO_PIN, 50)
servo.start(0)

# â€” LCD ì´ˆê¸°í™” (I2C addressëŠ” ì‹¤ì œ í™˜ê²½ì— ë§ì¶° ì¡°ì •) â€”
lcd = CharLCD('PCF8574', address=0x27, port=1, cols=16, rows=2)

def clear_and_print(line1, line2=''):
    """Clear the display and print two lines of text"""
    lcd.clear()
    lcd.write_string(line1.ljust(16)[:16])
    if line2:
        lcd.cursor_pos = (1, 0)
        lcd.write_string(line2.ljust(16)[:16])

# Pi Bì˜ APIì—ì„œ ì‚¬ìš©ì ì •ë³´ ì½ê¸°
def get_user_info(uid):
    """Fetch user info dict by UID from Pi B's API"""
    try:
        resp = requests.get(USER_API, timeout=2)
        if resp.status_code != 200:
            print(f"âš ï¸ Failed to fetch user data, HTTP status {resp.status_code}")
            return None
        users = resp.json()
        for u in users:
            if str(u.get('uid')) == uid:
                return u
    except json.JSONDecodeError as e:
        print(f"âš ï¸ JSON decode error fetching user data: {e}")
    except Exception as e:
        print(f"âš ï¸ User data fetch error: {e}")
    return None

# ë¸”ë¡ì²´ì¸ ì´ˆê¸°í™” ë° ë””ìŠ¤í¬ ë¡œë“œ
def load_chain():
    bchain = Blockchain(difficulty=2)
    if os.path.exists(CHAIN_FILE):
        with open(CHAIN_FILE, 'r', encoding='utf-8') as f:
            data = json.load(f)
        bchain.chain.clear()
        for blk in data:
            b = Block(blk['index'], blk['timestamp'], blk['data'], blk['previous_hash'])
            b.nonce, b.hash = blk['nonce'], blk['hash']
            bchain.chain.append(b)
        print(f"âœ… Loaded chain from {CHAIN_FILE} (length={len(bchain.chain)})")
    else:
        # ì´ˆê¸° genesis ì €ì¥
        with open(CHAIN_FILE, 'w', encoding='utf-8') as f:
            json.dump([b.__dict__ for b in bchain.chain], f, ensure_ascii=False, indent=2)
        shutil.copy2(CHAIN_FILE, BACKUP_FILE)
        print(f"ğŸ’¾ Initialized chain and backup with genesis block")
    return bchain

chain = load_chain()
PEERS = ["172.20.10.8:5000", "172.20.10.9:5001"]

# ì²´ì¸ ì €ì¥ ë° ë°±ì—… í•¨ìˆ˜
def save_and_backup_chain():
    with open(CHAIN_FILE, 'w', encoding='utf-8') as f:
        json.dump([b.__dict__ for b in chain.chain], f, ensure_ascii=False, indent=2)
    shutil.copy2(CHAIN_FILE, BACKUP_FILE)
    print(f"ğŸ’¾ Saved & backed up chain ({len(chain.chain)} blocks)")

# P2P ë¸”ë¡ ì „íŒŒ
def broadcast_block(block, proof):
    payload = {'block': block.__dict__, 'proof': proof}
    for peer in PEERS:
        try:
            requests.post(f"http://{peer}/add_block", json=payload, timeout=3)
        except:
            pass

# ì„œë³´ ëª¨í„° ì œì–´
def open_door():
    servo.ChangeDutyCycle(7.5)
    time.sleep(0.5)
    servo.ChangeDutyCycle(0)

def close_door():
    servo.ChangeDutyCycle(2.5)
    time.sleep(0.5)
    servo.ChangeDutyCycle(0)

# ë¸”ë¡ ìƒì„± ë° ì „íŒŒ
def create_and_broadcast(data):
    last = chain.last_block()
    blk  = Block(
        index=last.index + 1,
        timestamp=time.time(),
        data=data,
        previous_hash=last.hash
    )
    proof = chain.proof_of_work(blk)
    chain.add_block(blk, proof)
    print(f"âœ… Created block #{blk.index} â†’ {blk.hash}")
    broadcast_block(blk, proof)
    save_and_backup_chain()

# ë©”ì¸ ë£¨í”„
def main():
    print("â–¶ï¸ Sensor & Servo listener started (Ctrl+C to stop)")
    try:
        while True:
            # 1) Wait for tag
            clear_and_print('Please scan tag...', '')
            print("Please scan tag...")

            # 2) RFID ì½ê¸°
            try:
                uid, _ = READER.read()
                print(f"ğŸ“¶ Tag read: UID={uid}")
            except Exception as e:
                print(f"âš ï¸ RFID read error: {e}")
                time.sleep(1)
                continue

            uid_str = str(uid)
            # ì‚¬ìš©ì ì •ë³´ ì¡°íšŒ (ì´ë¦„ ë¯¸í‘œì‹œ)
            get_user_info(uid_str)  # í˜¸ì¶œë§Œ í•´ì„œ ìºì‹œí•˜ê±°ë‚˜ ë¡œê·¸ í™œìš© ê°€ëŠ¥

            # 3) Tag block & LCD í‘œì‹œ (UIDë§Œ í‘œì‹œ)
            clear_and_print(f'UID: {uid_str}', '')
            data_user = {
                'uid': uid_str,
                'username': '',
                'door': None,
                'time': time.strftime("%Y-%m-%dT%H:%M:%S")
            }
            create_and_broadcast(data_user)

            # 4) Door open
            time.sleep(2)
            open_door()
            clear_and_print('Access Open', '')
            while GPIO.input(PIN_DOOR) == GPIO.HIGH:
                time.sleep(0.1)

            data_open = {
                'uid': uid_str,
                'username': '',
                'door': 'open',
                'time': time.strftime("%Y-%m-%dT%H:%M:%S")
            }
            create_and_broadcast(data_open)

            # 5) Door close
            time.sleep(3)
            close_door()
            clear_and_print('Access Closed', '')
            while GPIO.input(PIN_DOOR) == GPIO.LOW:
                time.sleep(0.1)

            data_closed = {
                'uid': uid_str,
                'username': '',
                'door': 'closed',
                'time': time.strftime("%Y-%m-%dT%H:%M:%S")
            }
            create_and_broadcast(data_closed)

            # 6) Prompt for next scan
            clear_and_print('Please scan tag...', '')
            time.sleep(1)

    except KeyboardInterrupt:
        print("\nâ¹ï¸ Sensor & Servo listener stopped")
    finally:
        servo.stop()
        GPIO.cleanup()

if __name__ == "__main__":
    main()