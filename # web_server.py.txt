import eventlet
eventlet.monkey_patch()

import os, json, threading, time, traceback, requests
from flask import Flask, jsonify, render_template, request
from flask_cors import CORS
from flask_socketio import SocketIO
from blockchain import Blockchain, Block

app = Flask(
    __name__,
    static_folder='static',
    template_folder='templates'
)
CORS(app)
socketio = SocketIO(app, cors_allowed_origins="*")

# â€” íŒŒì¼ ê²½ë¡œ ì„¤ì • â€”
CHAIN_FILE    = 'chain_data.json'
BACKUP_FILE   = 'chain_backup.json'
USERS_FILE    = 'users_data.json'

# â€” ìŠ¤ë ˆë“œ ì œì–´ í”Œë˜ê·¸ â€” 
sync_enabled = True  # Falseì¼ ë•ŒëŠ” Aì„œë²„ ë™ê¸°í™” ì¤‘ë‹¨

# â€” ë¸”ë¡ì²´ì¸ ì´ˆê¸°í™” & ë°±ì—… ë¡œë“œ â€”
chain = Blockchain(difficulty=2)

def load_chain_from_file():
    if not os.path.exists(CHAIN_FILE):
        return
    with open(CHAIN_FILE, 'r', encoding='utf-8') as f:
        data = json.load(f)
    chain.chain.clear()
    for blk in data:
        b = Block(blk['index'], blk['timestamp'], blk['data'], blk['previous_hash'])
        b.nonce, b.hash = blk['nonce'], blk['hash']
        chain.chain.append(b)

def load_backup_chain():
    if not os.path.exists(BACKUP_FILE):
        with open(BACKUP_FILE, 'w', encoding='utf-8') as f:
            json.dump([], f, ensure_ascii=False, indent=2)
    with open(BACKUP_FILE, 'r', encoding='utf-8') as f:
        return json.load(f)

def update_backup_file():
    arr = [{
        'index': b.index,
        'timestamp': b.timestamp,
        'data': b.data,
        'previous_hash': b.previous_hash,
        'nonce': b.nonce,
        'hash': b.hash
    } for b in chain.chain]
    with open(BACKUP_FILE, 'w', encoding='utf-8') as f:
        json.dump(arr, f, ensure_ascii=False, indent=2)

# ìµœì´ˆ ë¡œë“œ
load_chain_from_file()
backup_chain = load_backup_chain()

# â€” ì‚¬ìš©ì ê´€ë¦¬ â€”
users = {}
def load_users_from_disk():
    if os.path.exists(USERS_FILE):
        try:
            with open(USERS_FILE, 'r', encoding='utf-8') as f:
                users.update(json.load(f))
        except:
            pass

def save_users_to_disk():
    with open(USERS_FILE, 'w', encoding='utf-8') as f:
        json.dump(users, f, ensure_ascii=False, indent=2)

load_users_from_disk()

# â€” ë™ê¸°í™” ì„¤ì • â€”
PEER_NODE     = '172.20.10.8:5000'
SYNC_INTERVAL = 1  # ì´ˆ

# ì „ì—­ watch_mtime (sync_chain ê³¼ watch_chain_file ê³µìœ )
watch_mtime = os.path.getmtime(CHAIN_FILE) if os.path.exists(CHAIN_FILE) else 0

def sync_chain():
    """ Aì„œë²„ì—ì„œ static/chain_data.jsonì„ ì£¼ê¸° ë™ê¸°í™” """
    global watch_mtime
    last_len = len(chain.chain)
    while True:
        time.sleep(SYNC_INTERVAL)
        if not sync_enabled:
            continue
        try:
            res = requests.get(f"http://{PEER_NODE}/static/chain_data.json", timeout=2)
            res.raise_for_status()
            remote_chain = res.json()
            # 1) íŒŒì¼ ë®ì–´ì“°ê¸°
            with open(CHAIN_FILE, 'w', encoding='utf-8') as f:
                json.dump(remote_chain, f, ensure_ascii=False, indent=2)
            # 2) ë©”ëª¨ë¦¬ ê°±ì‹ 
            chain.chain.clear()
            for blk in remote_chain:
                b = Block(blk['index'], blk['timestamp'], blk['data'], blk['previous_hash'])
                b.nonce, b.hash = blk['nonce'], blk['hash']
                chain.chain.append(b)
            # 3) ë°±ì—… ê°±ì‹ 
            update_backup_file()
            # 4) ë³€ê²½ëœ íŒŒì¼ì€ watchì—ì„œ ë¬´ì‹œ
            watch_mtime = os.path.getmtime(CHAIN_FILE)
            # 5) ìƒˆ ë¸”ë¡ í‘¸ì‹œ
            if len(chain.chain) > last_len:
                new_blk = chain.chain[-1]
                socketio.emit('new_block', {
                    'index':     new_blk.index,
                    'data':      new_blk.data,
                    'timestamp': new_blk.timestamp
                })
                last_len = len(chain.chain)
        except Exception as e:
            print(f"[SYNC ERROR] {e}")
            continue

def watch_chain_file():
    """ íŒŒì¼ ì‹œìŠ¤í…œ ë³€ê²½ì„ ê°ì‹œ, ë³€ì¡° ê²€ì‚¬ """
    global watch_mtime
    while True:
        time.sleep(1)
        if not os.path.exists(CHAIN_FILE):
            continue
        mtime = os.path.getmtime(CHAIN_FILE)
        if mtime == watch_mtime:
            continue
        watch_mtime = mtime  # ì´ ì‹œì ë¶€í„° ì§„ì§œ ë³€ê²½
        with open(CHAIN_FILE, 'r', encoding='utf-8') as f:
            current = json.load(f)
        backup = load_backup_chain()
        # â”€ ìƒˆ ë¸”ë¡ ì¶”ê°€ëœ ê²½ìš°ëŠ” ì •ìƒ ì²˜ë¦¬ â”€
        if len(current) > len(backup):
            chain.chain.clear()
            for blk in current:
                b = Block(blk['index'], blk['timestamp'], blk['data'], blk['previous_hash'])
                b.nonce, b.hash = blk['nonce'], blk['hash']
                chain.chain.append(b)
            update_backup_file()
            socketio.emit('tamper_cleared', {})
            continue
        # â”€ ê·¸ ì™¸ì—ë§Œ ë³€ì¡° ê²€ì‚¬ â”€
        chain.chain.clear()
        for blk in current:
            b = Block(blk['index'], blk['timestamp'], blk['data'], blk['previous_hash'])
            b.nonce, b.hash = blk['nonce'], blk['hash']
            chain.chain.append(b)
        diffs = []
        limit = min(len(current), len(backup))
        for i in range(limit):
            orig, cur = backup[i], current[i]
            idx = orig['index']
            if cur.get('data') != orig.get('data'):
                diffs.append({'index': idx, 'field': 'data', 'original': orig['data'], 'modified': cur['data']})
            if isinstance(orig['data'], dict) and isinstance(cur['data'], dict):
                for k in ('username','door'):
                    if orig['data'].get(k) != cur['data'].get(k):
                        diffs.append({'index': idx, 'field': k,
                                      'original': orig['data'].get(k),
                                      'modified': cur['data'].get(k)})
            b = chain.chain[i]
            if b.compute_hash() != b.hash:
                diffs.append({'index': idx, 'field': 'hash',
                              'original': b.compute_hash(), 'modified': b.hash})
        if diffs:
            print("[TAMPER DETECTED]", diffs)
            socketio.emit('tamper_detected', {'diffs': diffs})
        else:
            socketio.emit('tamper_cleared', {})

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ API ì—”ë“œí¬ì¸íŠ¸ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/api/toggle_sync', methods=['POST'])
def toggle_sync():
    """ sync_chain on/off í† ê¸€ """
    global sync_enabled
    sync_enabled = not sync_enabled
    return jsonify({'sync_enabled': sync_enabled})

@app.route('/api/tamper', methods=['POST'])
def tamper_block():
    """
    í…ŒìŠ¤íŠ¸ìš©: ë¡œì»¬ chain_data.json ì„ ì§ì ‘ ìˆ˜ì •í•©ë‹ˆë‹¤.
    JSON body:
      { "index":int, "field":str, "new_value":any }
    """
    payload = request.get_json() or {}
    idx       = payload.get('index')
    field     = payload.get('field')
    new_value = payload.get('new_value')

    # 1) íŒŒì¼ ë¡œë“œ
    with open(CHAIN_FILE, 'r', encoding='utf-8') as f:
        chain_data = json.load(f)

    # 2) ë³€ì¡°
    for blk in chain_data:
        if blk.get('index') == idx:
            if field in ('username','door') and isinstance(blk.get('data'), dict):
                blk['data'][field] = new_value
            else:
                blk[field] = new_value
            break

    # 3) ë®ì–´ì“°ê¸°
    with open(CHAIN_FILE, 'w', encoding='utf-8') as f:
        json.dump(chain_data, f, ensure_ascii=False, indent=2)

    return jsonify({'tampered': True}), 200

@app.route('/api/chain')
def api_chain():
    load_chain_from_file()
    return jsonify({'chain': [{
        'index': b.index, 'timestamp': b.timestamp, 'data': b.data,
        'previous_hash': b.previous_hash, 'nonce': b.nonce, 'hash': b.hash
    } for b in chain.chain]})

@app.route('/api/users', methods=['GET'])
def get_users():
    return jsonify([{'uid': u, 'username': nm} for u, nm in users.items()])

@app.route('/api/users', methods=['POST'])
def add_user():
    data = request.get_json() or {}
    uid, name = data.get('uid'), data.get('username')
    if not uid or not name:
        return jsonify({'error': 'uidì™€ usernameì„ ëª¨ë‘ ë³´ë‚´ì£¼ì„¸ìš”.'}), 400
    if uid in users:
        return jsonify({'error': 'ì´ë¯¸ ë“±ë¡ëœ UIDì…ë‹ˆë‹¤.'}), 409
    users[uid] = name; save_users_to_disk()
    return jsonify([{'uid': u, 'username': nm} for u, nm in users.items()]), 201

@app.route('/api/users/<uid>', methods=['DELETE'])
def del_user(uid):
    users.pop(uid, None); save_users_to_disk()
    return jsonify([{'uid': u, 'username': nm} for u, nm in users.items()]), 200

@app.route('/api/recover', methods=['POST'])
def recover_chain():
    global watch_mtime
    with open(CHAIN_FILE, 'r', encoding='utf-8') as f:
        current = json.load(f)
    backup = load_backup_chain()
    extras = current[len(backup):]
    new_chain = backup + extras
    with open(CHAIN_FILE, 'w', encoding='utf-8') as f:
        json.dump(new_chain, f, ensure_ascii=False, indent=2)
    load_chain_from_file()
    watch_mtime = os.path.getmtime(CHAIN_FILE)
    update_backup_file()
    socketio.emit('recovery_complete', {})
    socketio.emit('tamper_cleared', {})
    return jsonify(success=True), 200

@socketio.on('connect')
def handle_connect():
    print("ğŸ‘‰ UI connected")

if __name__ == '__main__':
    threading.Thread(target=sync_chain, daemon=True).start()
    threading.Thread(target=watch_chain_file, daemon=True).start()
    print("ğŸš€ Server starting on port 8000 â€¦")
    socketio.run(app, host='0.0.0.0', port=8000)
